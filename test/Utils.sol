// SPDX-License-Identifier: WTFPL.ETH
pragma solidity ^0.8.15;

/**
 * @title : Utils for IPFS2.eth
 * @author : freetib.eth, sshmatrix.eth
 */
contract Utils {
    /// @dev : Takes an encoded byte string as input and returns two string values as output. The function formats the input string into two parts: a path and a domain. It does so by parsing each label in the encoded string and concatenating them together using periods to form the domain and forward slashes to form the path. For example, given the input bytes "0x03656e73046170692d3106676f6f676c65", the output would be "google.com" and "en/api-1". (generated by ChatGPT-4)
    function Format(bytes calldata _encoded) external pure returns (string memory _path, string memory _domain) {
        uint256 n = 1;
        uint256 len = uint8(bytes1(_encoded[:1]));
        bytes memory _label;
        _label = _encoded[1:n += len];
        _path = string(_label);
        _domain = _path;
        while (_encoded[n] > 0x0) {
            len = uint8(bytes1(_encoded[n:++n]));
            _label = _encoded[n:n += len];
            _domain = string.concat(_domain, ".", string(_label));
            _path = string.concat(string(_label), "/", _path);
        }
    }

    /// @dev : Takes in an array of byte arrays called _names and returns a concatenated byte array _name and a computed name hash _namehash. It iterates through the _names array, prepending the length of each byte array to the concatenated _name byte array and computing the _namehash by hashing the current name with the previous _namehash. An example input could be ["ipfs2", "eth"] and the output would be _namehash = 0x5d3debe6ab0a8acfd6b3c7e24d3002e7c3a474cc41d456af66c2b4f9f3d7f4c9 and _name = 0x050569707673320365746800. This function is commonly used in ENS (Ethereum Name Service) to encode domain names. (generated by ChatGPT-4)
    function Encode(bytes[] memory _names) public pure returns (bytes32 _namehash, bytes memory _name) {
        uint256 i = _names.length;
        _name = abi.encodePacked(bytes1(0));
        _namehash = bytes32(0);
        unchecked {
            while (i > 0) {
                --i;
                _name = bytes.concat(bytes1(uint8(_names[i].length)), _names[i], _name);
                _namehash = keccak256(abi.encodePacked(_namehash, keccak256(_names[i])));
            }
        }
    }

    /// @dev : Takes a byte array _b, a start index _start, and an end index _end as input parameters and returns a new byte array containing the portion of the input byte array specified by the start and end indices. If _end is not specified or is set to zero, the function returns the portion of the input byte array from _start to the end of the byte array. For example, if _b contains the byte array [0x01, 0x02, 0x03, 0x04], calling chunk(_b, 1, 3) would return the byte array [0x02, 0x03]. (generated by ChatGPT-4)
    function chunk(bytes calldata _b, uint256 _start, uint256 _end) external pure returns (bytes memory) {
        return _b[_start:_end == 0 ? _b.length : _end];
    }
}
